## Question 1: Downloading sound

Chosen classes: violin, guitar, bassoon, trumpet, clarinet, cello, xiaoluo, daluo, flute, mridangam, xiaoluo

I took (0, 5) second interval everywhere. I've used "multisample" tag everywhere where possible. Naobo, mridangam and daluo didn't have enough sounds with that tag, so I've use None tags for them and it
worked well.

## Question 2: Obtaining a baseline clustering performance

In order to do descriptorPairScatterPlot, I had to define more colors in soundAnalysis.py, otherwise it crashed. Change was to make colors list like this:  

```python
colors = ['r', 'g', 'c', 'b', 'k', 'm', 'y', [.2, .7, .1], [.6, .3, .6], [.7, .2, .1]]
```
Launching the descriptorPairScatterPlot with different set of params had shown that some descriptors work better for some sounds, some work better for others.

Descriptors `0, 3`:

![0, 3](p2-img01-descriptor-0-3.png)

Descriptors `4, 8`:

![4, 8](p2-img02-descriptor-4-8.png)

Descriptors `10, 5`:

![10, 5](p2-img03-descriptor-10-5.png)

We can use these images to see which descriptors should improve our clustering in future.

Using descriptors `[0, 3]`, I got average of `statistics.mean([50.0, 50.5, 48.5, 50.5, 50.0, 51.0, 49.5, 50.5, 51.0, 49.5]) = 50.1`.

## Question 3: Improvements

Implementation can be seen in the attached code. First attemp â€“ use these classifiers:

- SpectralCentroidTime
- LogAttackTime
- SpectralContrast
- MFCC

Result accuracy: `statistics.mean([57.5, 56.5, 57.0]) = 57.0`

Adding a classifier `RollOff` didn't help much.

But changing stats metrics from `['mean', 'median']` to `['mean', 'var', 'min', 'max']`improved the accuracy to `statistics.mean([61, 66.5, 62.5]) = 63.3`!

## Question 3.2: Computing the descriptors stripping the silences and noise at the beginning/end

Let's pick few sounds and compute their energy:

`tmp/bassoon/154350/154350_2626346-hq.mp3`

![energy](p2-img04-energy.png)

`tmp/cello/42251/42251_7037-hq.mp3`

![energy](p2-img05-energy.png)

`./tmp/clarinet/248700/248700_6552981-hq.mp3`

![energy](p2-img06-energy.png)

It seems clear that there's no "one value fits all" for us and ideally we'd use some better statistical approach, but for analysis in our situation it should be sufficient to choose something like 0.1 and take a look.

Accuracy with stripped sounds is: `statistics.mean([55.5, 64.0, 64]) = 61.16`. It seems like our statistics decreased a bit, actually.

